{
    "collab_server" : "",
    "contents" : "\n# This is the server logic for a Shiny web application.\n# You can find out more about building applications with Shiny here:\n#\n# http://shiny.rstudio.com\n#\n\nlibrary(shiny)\nlibrary(reshape2)\nlibrary(ggplot2)\nlibrary(plotly)\n\nbetaMode <- function(alpha, beta) {\n  return((alpha - 1)/(alpha+beta-2))\n}\n\nbetaMean <- function(alpha, beta) {\n  return((alpha)/(alpha+beta))\n}\n\nbetaStd <- function(alpha, beta) {\n  return(sqrt((alpha * beta)/(((alpha + beta)**2) * (alpha + beta + 1))))\n}\n\nshinyServer(function(input, output) {\n  \n  x <- reactive({\n    set.seed(42)\n    x <- rbinom(input$n, size = 1, input$pi)\n  })\n  \n  output$samplingInput <- renderUI({\n    n <- input$n\n    \n    probInput <- numericInput(\"pi\", withMathJax(\"$$\\\\textbf{Success}\\\\ \\\\textbf{Probability}\\\\ \\\\pi$$\"), \n                              min = 0, max = 1, step=.1, value = .5)\n    successInput <- numericInput(\"k\", withMathJax(\"$$\\\\textbf{Number of Successes}\\\\ k$$\"), \n                                 min = 0, max = n, step=1, value = floor(n/2))\n    \n    uiElement <- switch(input$radioSample,\n                        \"prob\" = probInput,\n                        \"successes\" = successInput,\n                        probInput)\n    return(uiElement)\n    \n  })\n  \n  output$triPlot <- renderPlotly({\n    \n    prob <- input$prob ## success probability\n    x <- x()\n    n <- length(x)\n    \n    alpha <- input$alpha\n    beta  <- input$beta\n    pi <- seq(0, 1, length.out=1000)\n    \n    ## Data\n    \n    k <- switch(input$radioSample,\n                        \"prob\" = sum(x),\n                        \"successes\" = input$k,\n                        probInput)\n    \n    # k <- sum(x) ## number of successes\n    \n    # Likelihood p(x|pi_test) with x ~ Bin(pi_test, alpha_test, beta)\n    likelihood <- dbinom(k, n, pi)\n    likelihood <- likelihood/(sum(likelihood)/length(pi)) ## Normalize Density\n\n    ## Prior p(pi) based on Beta(pi, alpha, beta)\n    prior <- dbeta(pi, alpha, beta)\n    # prior <- prior/(sum(prior[!is.infinite(prior)])/length(pi)) ## Normalize Density\n    \n    ## Posterior Distribution p(pi|x)\n    posterior <- dbeta(pi, alpha+k, beta+n-k)\n    # posterior <- posterior/(sum(posterior)/length(pi)) ## Normalize Density\n    \n    data <- data.frame(Pi=pi, \n                       Posterior=posterior, Likelihood=likelihood, Prior=prior)\n    data.molten <- melt(data, id.vars = \"Pi\")\n    colnames(data.molten) <- c(\"Pi\", \"Function\", \"Density\")\n    \n    fig <- plot_ly(data.molten, x = ~Pi, y= ~Density,\n                   type = 'scatter', mode = 'lines', \n                   color = ~Function) %>%\n      layout(title = 'Density Functions',\n             hovermode=\"all\",\n             xaxis = list(title = 'Pi',\n                          tick0 = 0,\n                          dtick = 0.1),\n             yaxis = list(title = 'Density',\n                          range = c(0, max(data$Posterior, data$Likelihood))),\n             legend = list(orientation = 'h'))\n    \n    return(fig)\n  })\n  \n  output$posteriorProbPlot <- renderPlotly({\n    \n    prob <- input$prob ## success probability\n    x <- x()\n    n <- length(x)\n    \n    alpha <- input$alpha\n    beta  <- input$beta\n    pi <- seq(0, 1, length.out=1000)\n    \n    ## Data\n    k <- switch(input$radioSample,\n                \"prob\" = sum(x),\n                \"successes\" = input$k,\n                probInput)\n    \n    ## Posterior Distribution p(pi|x)\n    posterior <- dbeta(pi, alpha+k, beta+n-k)\n    posterior <- posterior/sum(posterior)\n    go_prob <- cumsum(posterior)\n    nogo_prob <- 1-cumsum(posterior)\n    \n    data <- data.frame(Pi=pi,\n                       Go=go_prob, \n                       NoGo=nogo_prob)\n    data.molten <- melt(data, id.vars = \"Pi\")\n    colnames(data.molten) <- c(\"Pi\", \"Function\", \"Probability\")\n    \n    fig <- plot_ly(data.molten, x = ~Pi, y= ~Probability,\n                   type = 'scatter', mode = 'lines', \n                   color = ~Function) %>%\n      layout(title = 'Probability Functions',\n             hovermode=\"all\",\n             xaxis = list(title = 'Pi',\n                          tick0 = 0,\n                          dtick = 0.1),\n             yaxis = list(title = 'Probability'),\n             legend = list(orientation = 'h'))\n    \n    return(fig)\n  })\n  \n  \n  output$priorDistFormula <- renderUI({\n    alpha <- input$alpha\n    beta <- input$beta\n    uiElement <- withMathJax(helpText(sprintf('$$\\\\begin{align}\n                                      p(\\\\theta)&=\\\\frac{\\\\theta^{\\\\alpha-1}(1-\\\\theta)^{\\\\beta-1}}{B(\\\\alpha, \\\\beta)}\n                                            \\\\\\\\&=Beta(\\\\theta|\\\\alpha, \\\\beta)\n                                            \\\\\\\\&=Beta(\\\\theta|\\\\textbf{%.2f}, \\\\textbf{%.2f})\n                                      \\\\end{align}$$', alpha, beta, alpha, beta, alpha, beta)))\n    return(uiElement)\n  })\n  \n  output$likelihoodFormula <- renderUI({\n    n <- input$n\n    k <- sum(x())\n    alpha <- input$alpha\n    beta <- input$beta\n    uiElement <- list(withMathJax(helpText(sprintf('$$X\\\\sim Bin(n, \\\\theta) = Bin(\\\\textbf{%i}, \\\\theta)$$', n))),\n                      withMathJax(helpText(sprintf('$$\\\\begin{align}\n                                      p(x|\\\\theta)&={n\\\\choose{x}}\\\\theta^{x}(1-\\\\theta)^{n-x}\n                                              \\\\\\\\&={\\\\textbf{%i}\\\\choose{\\\\textbf{%i}}}\\\\theta^{\\\\textbf{%i}}(1-\\\\theta)^{\\\\textbf{%i}}\n                                      \\\\end{align}$$', n, k, k, n-k))))\n    return(uiElement)\n  })\n  \n  output$posteriorFormula <- renderUI({\n    n <- input$n\n    k <- sum(x())\n    alpha <- input$alpha\n    beta <- input$beta\n    uiElement <- withMathJax(helpText(sprintf('$$\\\\begin{align}\n                                               p(\\\\theta|x)&=p(x|\\\\theta)p(\\\\theta)\n                                                       \\\\\\\\&=\\\\theta^{x}(1-\\\\theta)^{n-x}\\\\theta^{\\\\alpha-1}(1-\\\\theta)^{\\\\beta-1}\n                                                       \\\\\\\\&=\\\\theta^{(\\\\alpha+x)-1}(1-\\\\theta)^{(\\\\beta+n-x)-1}\n                                                       \\\\\\\\&=Beta(\\\\theta|\\\\alpha+x, \\\\beta+n-x)\n                                                       \\\\\\\\&=Beta(\\\\theta|\\\\textbf{%.2f}, \\\\textbf{%.2f})\n                                                   \\\\end{align}$$', sum(alpha, k), sum(beta, n, -k))))\n    return(uiElement)\n  })\n  \n  \n  output$pointEst_Prior <- renderTable({\n    validate(\n      need(!(input$n==0), NULL)\n    )\n    \n    alpha <- input$alpha\n    beta  <- input$beta\n    \n    beta_mode <- betaMode(alpha, beta)\n    beta_mean <- betaMean(alpha, beta)\n    beta_std  <- betaStd(alpha, beta)\n    \n    pE <- data.frame(Type=c(\"Mode\", \"Mean\", \"Std\"), \n                     PointEstimate=c(beta_mode, beta_mean, beta_std))\n    return(pE)\n  })\n  \n  output$pointEst_Likelihood <- renderTable({\n    x <- x()\n    n <- input$n\n    validate(\n      need(!(input$n==0), NULL)\n    )\n    \n    k <- switch(input$radioSample,\n                \"prob\" = sum(x),\n                \"successes\" = input$k,\n                probInput)\n    \n    alpha <- k + 1\n    beta <- n - k + 1\n    \n    beta_mode <- betaMode(alpha, beta)\n    beta_mean <- betaMean(alpha, beta)\n    beta_std  <- betaStd(alpha, beta)\n    \n    pE <- data.frame(Type=c(\"Mode\", \"Mean\", \"Std\"), \n                     PointEstimate=c(beta_mode, beta_mean, beta_std))\n    return(pE)\n  })\n  \n  output$pointEst_Posterior <- renderTable({\n    x <- x()\n    n <- input$n\n    validate(\n      need(n!=0, NULL)\n    )\n    \n    k <- switch(input$radioSample,\n                \"prob\" = sum(x),\n                \"successes\" = input$k,\n                probInput)\n    \n    alpha <- input$alpha + k\n    beta <- input$beta + n - k\n    \n    beta_mode <- betaMode(alpha, beta)\n    beta_mean <- betaMean(alpha, beta)\n    beta_std  <- betaStd(alpha, beta)\n    \n    pE <- data.frame(Type=c(\"Mode\", \"Mean\", \"Std\"), \n                     PointEstimate=c(beta_mode, beta_mean, beta_std))\n    return(pE)\n    \n  })\n  \n})\n",
    "created" : 1494430953810.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "12|35|14|0|\n16|35|18|0|\n20|34|22|0|\n26|17|29|2|\n31|36|45|2|\n47|34|96|2|\n98|44|138|2|\n141|39|150|2|\n152|40|163|2|\n165|39|178|2|\n181|40|196|2|\n198|45|220|2|\n222|44|245|2|\n",
    "hash" : "2218267454",
    "id" : "D213085F",
    "lastKnownWriteTime" : 1496331580,
    "last_content_update" : 1496331586415,
    "path" : "~/workspace/R/projects/BayesianSampleSize/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}